pipeline{
    agent any
    environment {
        AWS_ACCESS_KEY_ID = credentials('AWS_ACCESS_KEY_ID')
        AWS_SECRET_ACCESS_KEY = credentials('AWS_SECRET_ACCESS_KEY')
        AWS_DEFAULT_REGION = "ap-southeast-1"
        CLUSTER_NAME = "ballandbeer-dev-eks"
        REPO_URL = "https://github.com/haihhdev/ballandbeer.git"
        BRANCH_NAME = "master"
        GITHUB_TOKEN = credentials('GITHUB_TOKEN')
        TERRAFORM_DIR = "ops/tf-aws-eks"
        TF_VARS_FILE = "variables/dev.tfvars"
        MONITORING_NAMESPACE = "monitoring"
        KUBE_PROM_VALUES_FILE = "ops/monitoring/kube-prometheus-stack-values.yaml"
        ARGOCD_NAMESPACE = "argocd"
        ARGOCD_VALUES_FILE = "ops/argocd/argocd-values.yaml"
    }
    stages {
        stage('Checkout SCM') {
            steps {
                script {
                    checkout scmGit(branches: [[name: "*/${BRANCH_NAME}"]], extensions: [], userRemoteConfigs: [[url: "${REPO_URL}"]])
                }
            }
        }
        stage('Cleanup LoadBalancers') {
            when {
                expression { return params.action == 'destroy' }
            }
            steps {
                script {
                    sh """
                        aws eks update-kubeconfig --name ${CLUSTER_NAME} --region ${AWS_DEFAULT_REGION} || true
                        kubectl delete svc argocd-server -n argocd --ignore-not-found=true || true
                        kubectl delete svc redpanda-console -n redpanda --ignore-not-found=true || true
                        kubectl delete svc ingress-nginx-controller -n ingress-nginx --ignore-not-found=true || true
                        sleep 30
                        helm uninstall keda -n keda || true
                        helm uninstall cluster-autoscaler -n kube-system || true
                        helm uninstall k6-operator -n k6-operator-system || true
                        helm uninstall argocd -n argocd || true
                        helm uninstall redpanda -n redpanda || true
                        helm uninstall kube-prometheus-stack -n monitoring || true
                    """
                }
            }
        }
        
        stage('Creating/Destroying EKS Cluster'){
            steps {
                script {
                    dir("${TERRAFORM_DIR}"){
                        sh 'terraform init -reconfigure'
                        sh 'terraform validate'
                        sh "terraform plan -var-file=${TF_VARS_FILE}"
                        sh "terraform $action -var-file=${TF_VARS_FILE} -auto-approve" 
                    }
                }
            }
        }

        stage('Update Kubeconfig') {
            when {
                expression { return params.action == 'apply' }
            }
            steps {
                script {
                    sh "aws eks update-kubeconfig --name ${CLUSTER_NAME} --region ${AWS_DEFAULT_REGION}"
                }
            }
        }

        stage('Setup Helm Repositories') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh '''
                        helm repo add prometheus-community https://prometheus-community.github.io/helm-charts || true
                        helm repo add argo https://argoproj.github.io/argo-helm || true
                        helm repo add autoscaler https://kubernetes.github.io/autoscaler || true
                        helm repo add redpanda https://charts.redpanda.com || true
                        helm repo add grafana https://grafana.github.io/helm-charts || true
                        helm repo add kedacore https://kedacore.github.io/charts || true
                        helm repo update
                    '''
                }
            }
        }

        // Parallel installation of independent infrastructure components
        stage('Parallel Infrastructure Setup') {
            when {
                expression { return params.action == 'apply'}
            }
            parallel {
                stage('Install Monitoring Stack') {
                    steps {
                        script {
                            sh """
                                kubectl create namespace ${MONITORING_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                                
                                # Clean up any failed webhooks from previous runs
                                kubectl delete validatingwebhookconfigurations.admissionregistration.k8s.io \
                                    kube-prometheus-stack-admission --ignore-not-found=true
                                
                                # Install with increased timeout for hooks
                                helm upgrade --install kube-prometheus-stack prometheus-community/kube-prometheus-stack \
                                    --namespace ${MONITORING_NAMESPACE} \
                                    -f ops/monitoring/kube-prometheus-stack-values.yaml \
                                    --wait --timeout 10m \
                                    --set prometheusOperator.admissionWebhooks.enabled=true \
                                    --set prometheusOperator.admissionWebhooks.timeoutSeconds=10
                                
                                # Wait for critical components
                                echo "Waiting for Prometheus Operator..."
                                kubectl wait --for=condition=ready pod -l "app.kubernetes.io/name=prometheus-operator" \
                                    -n ${MONITORING_NAMESPACE} --timeout=300s || true
                                
                                echo "Waiting for Grafana..."
                                kubectl wait --for=condition=ready pod -l "app.kubernetes.io/name=grafana" \
                                    -n ${MONITORING_NAMESPACE} --timeout=300s || true
                            """
                        }
                    }
                }

                stage('Install K6 Operator') {
                    steps {
                        script {
                            sh """
                                curl -s https://raw.githubusercontent.com/grafana/k6-operator/main/bundle.yaml | kubectl apply -f -
                                kubectl wait --for=condition=ready pod -l "control-plane=controller-manager" \
                                    -n k6-operator-system --timeout=120s || true
                            """
                        }
                    }
                }

                stage('Install Nginx Ingress') {
                    stages {
                        stage('Deploy Nginx') {
                            steps {
                                script {
                                    sh '''
                                        kubectl create namespace ballandbeer --dry-run=client -o yaml | kubectl apply -f -
                                        
                                        echo "Deploying Nginx Ingress Controller..."
                                        kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.10.1/deploy/static/provider/aws/deploy.yaml
                                        
                                        echo "Waiting for Nginx deployment to be created..."
                                        kubectl wait --namespace ingress-nginx --for=condition=available deployment/ingress-nginx-controller --timeout=300s
                                        
                                        echo "Waiting for Nginx pods to be ready..."
                                        kubectl wait --namespace ingress-nginx --for=condition=ready pod \
                                            --selector=app.kubernetes.io/component=controller --timeout=300s
                                        
                                        echo "Applying monitoring configuration..."
                                        kubectl apply -f ops/monitoring/nginx-ingress-configmap.yaml
                                        kubectl apply -f ops/monitoring/nginx-ingress-servicemonitor.yaml
                                    '''
                                }
                            }
                        }
                        stage('Enable Nginx Metrics') {
                            steps {
                                script {
                                    sh '''
                                        # Wait for deployment to be fully available first
                                        echo "Ensuring Nginx controller is ready before patching..."
                                        kubectl wait deployment ingress-nginx-controller -n ingress-nginx \
                                            --for=condition=Available --timeout=300s || true
                                        
                                        # Check if metrics port already exists
                                        if ! kubectl get deployment ingress-nginx-controller -n ingress-nginx -o json | \
                                           jq -e '.spec.template.spec.containers[0].ports[] | select(.name=="metrics")' > /dev/null 2>&1; then
                                            echo "Adding metrics port..."
                                            kubectl patch deployment ingress-nginx-controller -n ingress-nginx --type='json' -p='[
                                                {
                                                    "op": "add",
                                                    "path": "/spec/template/spec/containers/0/ports/-",
                                                    "value": {
                                                    "containerPort": 10254,
                                                    "name": "metrics",
                                                    "protocol": "TCP"
                                                    }
                                                }
                                            ]' || echo "Port already exists or patch failed"
                                        else
                                            echo "Metrics port already configured"
                                        fi
                                        
                                        # Enable metrics in args
                                        echo "Enabling metrics in controller args..."
                                        kubectl get deployment ingress-nginx-controller -n ingress-nginx -o json | \
                                        jq '.spec.template.spec.containers[0].args |= map(if . == "--enable-metrics=false" then "--enable-metrics=true" else . end)' | \
                                        kubectl apply -f -
                                        
                                        # Wait for rollout with extended timeout
                                        echo "Waiting for controller rollout..."
                                        kubectl rollout status deployment ingress-nginx-controller -n ingress-nginx --timeout=5m || {
                                            echo "Rollout timeout, checking pod status..."
                                            kubectl get pods -n ingress-nginx
                                            kubectl describe deployment ingress-nginx-controller -n ingress-nginx
                                        }
                                        
                                        # Final verification
                                        kubectl wait --namespace ingress-nginx --for=condition=ready pod \
                                            --selector=app.kubernetes.io/component=controller --timeout=300s || true
                                    '''
                                }
                            }
                        }
                    }
                }

                stage('Install Cluster Autoscaler') {
                    steps {
                        script {
                            sh """
                                CA_ROLE_ARN=\$(terraform -chdir=${TERRAFORM_DIR} output -raw cluster_autoscaler_role_arn)
                                echo "CA Role ARN: \${CA_ROLE_ARN}"
                                helm upgrade --install cluster-autoscaler autoscaler/cluster-autoscaler \
                                    --version 9.51.0 \
                                    --namespace kube-system \
                                    -f ops/k8s/infra/cluster-autoscaler-values.yaml \
                                    --set rbac.serviceAccount.annotations."eks\\.amazonaws\\.com/role-arn"="\${CA_ROLE_ARN}"
                                kubectl wait --for=condition=ready pod -l "app.kubernetes.io/name=aws-cluster-autoscaler" \
                                    -n kube-system --timeout=120s || true
                            """
                        }
                    }
                }

                stage('Install Metrics Server') {
                    steps {
                        script {
                            sh '''
                                kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
                                kubectl wait --for=condition=ready pod -l "k8s-app=metrics-server" -n kube-system --timeout=120s || true
                            '''
                        }
                    }
                }

                stage('Install KEDA') {
                    steps {
                        script {
                            sh '''
                                helm upgrade --install keda kedacore/keda --namespace keda --create-namespace
                                kubectl wait --for=condition=ready pod -l "app.kubernetes.io/name=keda-operator" -n keda --timeout=120s || true
                            '''
                        }
                    }
                }
            }
        }

        // Parallel installation of ArgoCD and Redpanda
        stage('Parallel Application Infrastructure') {
            when {
                expression { return params.action == 'apply'}
            }
            parallel {
                stage('Install ArgoCD') {
                    steps {
                        script {
                            sh """
                                kubectl create namespace ${ARGOCD_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                                helm upgrade --install argocd argo/argo-cd \
                                    --namespace ${ARGOCD_NAMESPACE} -f ${ARGOCD_VALUES_FILE}
                                kubectl wait --for=condition=ready pod -l "app.kubernetes.io/name=argocd-server" \
                                    -n ${ARGOCD_NAMESPACE} --timeout=120s
                            """
                        }
                    }
                }

                stage('Install Redpanda & Console') {
                    steps {
                        script {
                            sh """
                                kubectl create namespace redpanda --dry-run=client -o yaml | kubectl apply -f -
                                helm upgrade --install redpanda redpanda/redpanda \
                                    --namespace redpanda \
                                    -f ops/k8s/infra/redpanda-values.yaml
                                kubectl wait --for=condition=ready pod/redpanda-0 -n redpanda --timeout=300s
                                kubectl exec -n redpanda redpanda-0 -- rpk topic create order-topic --brokers=localhost:9093 || true
                            """
                        }
                    }
                }
            }
        }

        stage('Deploy ArgoCD Applications') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    def apps = ['authen', 'booking', 'order', 'product', 'profile', 'frontend', 'recommender', 'infra', 'collector', 'ml-autoscaler']
                    for (svc in apps) {
                        try {
                            sh "kubectl apply -f ops/k8s/${svc}/overlays/dev/argocd-app.yaml -n argocd"
                        } catch (Exception e) {
                            echo "Failed to deploy ${svc}: ${e.message}"
                            currentBuild.result = 'UNSTABLE'
                        }
                    }
                }
            }
        }

        stage('Setup K6 Load Test Infrastructure') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh '''
                        echo "Creating K6 PriorityClass..."
                        kubectl apply -f services/collector/k6/k6-priorityclass.yaml
                        
                        echo "Creating K6 Training Script ConfigMap..."
                        kubectl create configmap k6-training-script -n ballandbeer \
                            --from-file=training-traffic.js=services/collector/k6/training-traffic.js \
                            --dry-run=client -o yaml | kubectl apply -f -
                        
                        # Verify ConfigMap was created
                        kubectl get configmap k6-training-script -n ballandbeer || {
                            echo "ERROR: ConfigMap not created"
                            exit 1
                        }
                        
                        echo "K6 infrastructure ready. To run training job:"
                        echo "  kubectl apply -f services/collector/k6/k6-training-job.yaml"
                    '''
                }
            }
        }

        stage('Add GitHub Webhook') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    def jenkinsUrl = "http://your-jenkins-url"
                    def webhookUrl = "${jenkinsUrl}/github-webhook/"
                    sh """
                        curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" \
                        -H "Accept: application/vnd.github.v3+json" \
                        https://api.github.com/repos/haihhdev/ballandbeer/hooks \
                        -d '{"name":"web","active":true,"events":["push","pull_request"],"config":{"url":"${webhookUrl}","content_type":"json","insecure_ssl":"0"}}' || true
                    """
                }
            }
        }

        stage('Show Cluster Info') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh '''
                        kubectl apply -f ops/k8s/ingress.yaml -n ballandbeer
                        
                        echo "\n========== ACCESS INFO =========="
                        GRAFANA_PASS=$(kubectl get secret kube-prometheus-stack-grafana -n monitoring -o jsonpath="{.data.admin-password}" | base64 -d)
                        echo "Grafana Password: $GRAFANA_PASS"
                        
                        ARGOCD_PASS=$(kubectl get secret -n argocd argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
                        echo "ArgoCD Password: $ARGOCD_PASS"
                        
                        ARGOCD_URL=$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                        echo "ArgoCD URL: $ARGOCD_URL"
                        
                        INGRESS_URL=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                        echo "Ingress URL: $INGRESS_URL"
                        
                        REDPANDA_URL=$(kubectl get svc redpanda-console -n redpanda -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                        echo "Redpanda URL: $REDPANDA_URL"
                        
                        echo "\nGrafana: http://localhost:3000 (admin/$GRAFANA_PASS)"
                        echo "  Port-forward: kubectl port-forward svc/kube-prometheus-stack-grafana -n monitoring 3000:80"
                        echo "ArgoCD: http://$ARGOCD_URL (admin/$ARGOCD_PASS)"
                        echo "Ingress: $INGRESS_URL"
                        echo "Redpanda: $REDPANDA_URL"
                        
                        echo "\n========== HPA STATUS =========="
                        kubectl get hpa -n ballandbeer
                        echo "\nTrigger scaling: kubectl apply -f services/collector/k6/k6-weekday-test.yaml"
                        echo "Monitor: kubectl get hpa -n ballandbeer -w"
                    '''
                }
            }
        }
    }
}