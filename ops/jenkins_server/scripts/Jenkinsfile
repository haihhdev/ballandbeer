pipeline{
    agent any
    environment {
        AWS_ACCESS_KEY_ID = credentials('AWS_ACCESS_KEY_ID')
        AWS_SECRET_ACCESS_KEY = credentials('AWS_SECRET_ACCESS_KEY')
        AWS_DEFAULT_REGION = "ap-southeast-1"
        CLUSTER_NAME = "ballandbeer-dev-eks"
        REPO_URL = "https://github.com/haihhdev/ballandbeer.git"
        BRANCH_NAME = "master"
        GITHUB_TOKEN = credentials('GITHUB_TOKEN')
        TERRAFORM_DIR = "ops/tf-aws-eks"
        TF_VARS_FILE = "variables/dev.tfvars"
        MONITORING_NAMESPACE = "monitoring"
        KUBE_PROM_VALUES_FILE = "ops/monitoring/kube-prometheus-stack-values.yaml"
        ARGOCD_NAMESPACE = "argocd"
        ARGOCD_VALUES_FILE = "ops/argocd/argocd-values.yaml"
    }
    stages {
        stage('Checkout SCM') {
            steps {
                script {
                    checkout scmGit(branches: [[name: "*/${BRANCH_NAME}"]], extensions: [], userRemoteConfigs: [[url: "${REPO_URL}"]])
                }
            }
        }
        stage('Cleanup LoadBalancers') {
            when {
                expression { return params.action == 'destroy' }
            }
            steps {
                script {
                    sh """
                        aws eks update-kubeconfig --name ${CLUSTER_NAME} --region ${AWS_DEFAULT_REGION} || true
                        kubectl delete svc argocd-server -n argocd --ignore-not-found=true || true
                        kubectl delete svc redpanda-console -n redpanda --ignore-not-found=true || true
                        kubectl delete svc ingress-nginx-controller -n ingress-nginx --ignore-not-found=true || true
                        sleep 30
                        helm uninstall cluster-autoscaler -n kube-system || true
                        helm uninstall k6-operator -n k6-operator-system || true
                        helm uninstall argocd -n argocd || true
                        helm uninstall redpanda -n redpanda || true
                        helm uninstall kube-prometheus-stack -n monitoring || true
                    """
                }
            }
        }
        
        stage('Creating/Destroying EKS Cluster'){
            steps {
                script {
                    dir("${TERRAFORM_DIR}"){
                        sh 'terraform init -reconfigure'
                        sh 'terraform validate'
                        sh "terraform plan -var-file=${TF_VARS_FILE}"
                        sh "terraform $action -var-file=${TF_VARS_FILE} -auto-approve" 
                    }
                }
            }
        }

        stage('Update Kubeconfig') {
            when {
                expression { return params.action == 'apply' }
            }
            steps {
                script {
                    sh "aws eks update-kubeconfig --name ${CLUSTER_NAME} --region ${AWS_DEFAULT_REGION}"
                }
            }
        }

        stage('Setup Helm Repositories') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh '''
                        helm repo add prometheus-community https://prometheus-community.github.io/helm-charts || true
                        helm repo add argo https://argoproj.github.io/argo-helm || true
                        helm repo add autoscaler https://kubernetes.github.io/autoscaler || true
                        helm repo add redpanda https://charts.redpanda.com || true
                        helm repo add grafana https://grafana.github.io/helm-charts || true
                        helm repo update
                    '''
                }
            }
        }

        stage('Install kube-prometheus-stack') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh """
                        kubectl create namespace ${MONITORING_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                        helm upgrade --install kube-prometheus-stack prometheus-community/kube-prometheus-stack \
                            --namespace ${MONITORING_NAMESPACE} \
                            -f ops/monitoring/kube-prometheus-stack-values.yaml
                        kubectl wait --for=condition=ready pod -l "app.kubernetes.io/name=grafana" \
                            -n ${MONITORING_NAMESPACE} --timeout=120s
                    """
                }
            }
        }

        stage('Install K6 Operator') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh """
                        curl -s https://raw.githubusercontent.com/grafana/k6-operator/main/bundle.yaml | kubectl apply -f -
                        kubectl wait --for=condition=ready pod -l "control-plane=controller-manager" \
                            -n k6-operator-system --timeout=120s || true
                    """
                }
            }
        }

        stage('Install Infrastructure Prerequisites') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh '''
                        kubectl create namespace ballandbeer --dry-run=client -o yaml | kubectl apply -f -
                        kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.10.1/deploy/static/provider/aws/deploy.yaml
                        kubectl wait --namespace ingress-nginx --for=condition=ready pod \
                            --selector=app.kubernetes.io/component=controller --timeout=120s || true
                        kubectl apply -f ops/monitoring/nginx-ingress-configmap.yaml
                        kubectl apply -f ops/monitoring/nginx-ingress-servicemonitor.yaml
                        kubectl wait --namespace ingress-nginx --for=condition=ready pod \
                            --selector=app.kubernetes.io/component=controller --timeout=120s || true
                    '''
                }
            }
        }

        stage('Enable Nginx Metrics') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh '''
                        kubectl patch deployment ingress-nginx-controller -n ingress-nginx --type='json' -p='[
                            {
                                "op": "add",
                                "path": "/spec/template/spec/containers/0/ports/-",
                                "value": {
                                "containerPort": 10254,
                                "name": "metrics",
                                "protocol": "TCP"
                                }
                            }
                        ]'
                        kubectl get deployment ingress-nginx-controller -n ingress-nginx -o json | \
                        jq '.spec.template.spec.containers[0].args |= map(if . == "--enable-metrics=false" then "--enable-metrics=true" else . end)' | \
                        kubectl apply -f -
                        kubectl rollout status deployment ingress-nginx-controller -n ingress-nginx --timeout=2m
                    '''
                }
            }
        }

        stage('Install Cluster Autoscaler') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh """
                        CA_ROLE_ARN=\$(terraform -chdir=${TERRAFORM_DIR} output -raw cluster_autoscaler_role_arn)
                        echo "CA Role ARN: \${CA_ROLE_ARN}"
                        helm upgrade --install cluster-autoscaler autoscaler/cluster-autoscaler \
                            --namespace kube-system \
                            -f ops/k8s/infra/cluster-autoscaler-values.yaml \
                            --set rbac.serviceAccount.annotations."eks\\.amazonaws\\.com/role-arn"="\${CA_ROLE_ARN}"
                        kubectl wait --for=condition=ready pod -l "app.kubernetes.io/name=aws-cluster-autoscaler" \
                            -n kube-system --timeout=120s || true
                    """
                }
            }
        }

        stage('Install Metrics Server') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh '''
                        kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml
                        kubectl wait --for=condition=ready pod -l "k8s-app=metrics-server" -n kube-system --timeout=120s || true
                    '''
                }
            }
        }

        stage('Install ArgoCD') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh """
                        kubectl create namespace ${ARGOCD_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                        helm upgrade --install argocd argo/argo-cd \
                            --namespace ${ARGOCD_NAMESPACE} -f ${ARGOCD_VALUES_FILE}
                        kubectl wait --for=condition=ready pod -l "app.kubernetes.io/name=argocd-server" \
                            -n ${ARGOCD_NAMESPACE} --timeout=120s
                    """
                }
            }
        }

        stage('Install Redpanda & Console') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh """
                        kubectl create namespace redpanda --dry-run=client -o yaml | kubectl apply -f -
                        helm upgrade --install redpanda redpanda/redpanda \
                            --namespace redpanda \
                            -f ops/k8s/infra/redpanda-values.yaml
                        kubectl wait --for=condition=ready pod/redpanda-0 -n redpanda --timeout=300s
                        kubectl exec -n redpanda redpanda-0 -- rpk topic create order-topic --brokers=localhost:9093 || true
                    """
                }
            }
        }

        stage('Deploy ArgoCD Applications') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    def apps = ['authen', 'booking', 'order', 'product', 'profile', 'frontend', 'recommender', 'infra', 'collector']
                    for (svc in apps) {
                        try {
                            sh "kubectl apply -f ops/k8s/${svc}/overlays/dev/argocd-app.yaml -n argocd"
                        } catch (Exception e) {
                            echo "Failed to deploy ${svc}: ${e.message}"
                            currentBuild.result = 'UNSTABLE'
                        }
                    }
                }
            }
        }

        stage('Setup K6 Load Test Infrastructure') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh '''
                        kubectl apply -f services/collector/k6/k6-priorityclass.yaml
                        kubectl create configmap k6-weekday-script -n ballandbeer \
                            --from-file=weekday-traffic.js=services/collector/k6/weekday-traffic.js \
                            --dry-run=client -o yaml | kubectl apply -f -
                        kubectl create configmap k6-weekend-script -n ballandbeer \
                            --from-file=weekend-traffic.js=services/collector/k6/weekend-traffic.js \
                            --dry-run=client -o yaml | kubectl apply -f -
                    '''
                }
            }
        }

        stage('Add GitHub Webhook') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    def jenkinsUrl = "http://your-jenkins-url"
                    def webhookUrl = "${jenkinsUrl}/github-webhook/"
                    sh """
                        curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" \
                        -H "Accept: application/vnd.github.v3+json" \
                        https://api.github.com/repos/haihhdev/ballandbeer/hooks \
                        -d '{"name":"web","active":true,"events":["push","pull_request"],"config":{"url":"${webhookUrl}","content_type":"json","insecure_ssl":"0"}}' || true
                    """
                }
            }
        }

        stage('Show Cluster Info') {
            when {
                expression { return params.action == 'apply'}
            }
            steps {
                script {
                    sh '''
                        kubectl apply -f ops/k8s/ingress.yaml -n ballandbeer
                        
                        echo "\n========== ACCESS INFO =========="
                        GRAFANA_PASS=$(kubectl get secret kube-prometheus-stack-grafana -n monitoring -o jsonpath="{.data.admin-password}" | base64 -d)
                        echo "Grafana Password: $GRAFANA_PASS"
                        
                        ARGOCD_PASS=$(kubectl get secret -n argocd argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
                        echo "ArgoCD Password: $ARGOCD_PASS"
                        
                        ARGOCD_URL=$(kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                        echo "ArgoCD URL: $ARGOCD_URL"
                        
                        INGRESS_URL=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                        echo "Ingress URL: $INGRESS_URL"
                        
                        REDPANDA_URL=$(kubectl get svc redpanda-console -n redpanda -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                        echo "Redpanda URL: $REDPANDA_URL"
                        
                        echo "\nGrafana: http://localhost:3000 (admin/$GRAFANA_PASS)"
                        echo "  Port-forward: kubectl port-forward svc/kube-prometheus-stack-grafana -n monitoring 3000:80"
                        echo "ArgoCD: http://$ARGOCD_URL (admin/$ARGOCD_PASS)"
                        echo "Ingress: $INGRESS_URL"
                        echo "Redpanda: $REDPANDA_URL"
                        
                        echo "\n========== HPA STATUS =========="
                        kubectl get hpa -n ballandbeer
                        echo "\nTrigger scaling: kubectl apply -f services/collector/k6/k6-weekday-test.yaml"
                        echo "Monitor: kubectl get hpa -n ballandbeer -w"
                    '''
                }
            }
        }
    }
}